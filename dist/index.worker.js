/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/heap/index.js":
/*!************************************!*\
  !*** ./node_modules/heap/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./lib/heap */ \"./node_modules/heap/lib/heap.js\");\n\n\n//# sourceURL=webpack://pathfinding-worker/./node_modules/heap/index.js?");

/***/ }),

/***/ "./node_modules/heap/lib/heap.js":
/*!***************************************!*\
  !*** ./node_modules/heap/lib/heap.js ***!
  \***************************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  (function(root, factory) {\n    if (true) {\n      return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n  })(this, function() {\n    return Heap;\n  });\n\n}).call(this);\n\n\n//# sourceURL=webpack://pathfinding-worker/./node_modules/heap/lib/heap.js?");

/***/ }),

/***/ "./src/node/index.ts":
/*!***************************!*\
  !*** ./src/node/index.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PathfindingNode = void 0;\nclass PathfindingNode {\n    position;\n    distance;\n    parent = null;\n    cost;\n    constructor({ position, cost = 1.0, distance, }) {\n        this.position = { ...position };\n        this.distance = distance;\n        this.cost = cost;\n    }\n    getBetterGuessDistance() {\n        return this.cost + this.distance;\n    }\n    getCost() {\n        return this.cost;\n    }\n    setCost(cost) {\n        this.cost = cost;\n    }\n    getParent() {\n        return this.parent;\n    }\n    setParent(parent) {\n        this.parent = parent;\n    }\n    compute() {\n        const path = [{ ...this.position }];\n        const cost = this.parent ? this.parent.getCost() : 0;\n        let parent = this.getParent();\n        while (parent) {\n            path.push({ ...parent.position });\n            parent = parent.getParent();\n        }\n        path.reverse();\n        return { path, cost };\n    }\n    getNextCost(shift, points) {\n        const nextPosition = {\n            x: this.position.x + shift.x,\n            y: this.position.y + shift.y,\n        };\n        const cost = points[nextPosition.y]?.[nextPosition.x] ?? 1.0;\n        if (Math.abs(shift.x) + Math.abs(shift.y) !== 1) {\n            return (cost * Math.SQRT2 +\n                (points[this.position.y]?.[nextPosition.x] ?? 0.0) +\n                (points[nextPosition.y]?.[this.position.x] ?? 0.0));\n        }\n        return cost;\n    }\n}\nexports.PathfindingNode = PathfindingNode;\n\n\n//# sourceURL=webpack://pathfinding-worker/./src/node/index.ts?");

/***/ }),

/***/ "./src/process/const.ts":
/*!******************************!*\
  !*** ./src/process/const.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PATHFINDING_PROCESS_NEXT_DIRECTIINS_DIAGONAL = exports.PATHFINDING_PROCESS_NEXT_DIRECTIINS_STRAIGHT = exports.PATHFINDING_PROCESS_LOOP_RATE = void 0;\nexports.PATHFINDING_PROCESS_LOOP_RATE = 200;\nexports.PATHFINDING_PROCESS_NEXT_DIRECTIINS_STRAIGHT = {\n    R: { x: 1, y: 0 }, // →\n    L: { x: -1, y: 0 }, // ←\n    D: { x: 0, y: 1 }, // ↓\n    U: { x: 0, y: -1 }, // ↑\n};\nexports.PATHFINDING_PROCESS_NEXT_DIRECTIINS_DIAGONAL = {\n    RD: { x: 1, y: 1 }, // ↘\n    RU: { x: 1, y: -1 }, // ↗\n    LU: { x: -1, y: -1 }, // ↖\n    LD: { x: -1, y: 1 }, // ↙\n};\n\n\n//# sourceURL=webpack://pathfinding-worker/./src/process/const.ts?");

/***/ }),

/***/ "./src/process/index.ts":
/*!******************************!*\
  !*** ./src/process/index.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PathfindingProcess = void 0;\nconst const_1 = __webpack_require__(/*! ./const */ \"./src/process/const.ts\");\nclass PathfindingProcess {\n    grids;\n    pointsCost = [];\n    taskQueue = [];\n    timer;\n    constructor(grids) {\n        this.grids = grids;\n        this.timer = setInterval(() => {\n            try {\n                this.next();\n            }\n            catch (error) {\n                console.error(error);\n            }\n        }, const_1.PATHFINDING_PROCESS_LOOP_RATE);\n    }\n    destroy() {\n        clearTimeout(this.timer);\n    }\n    createTask(task) {\n        this.taskQueue.push(task);\n    }\n    cancelTask(idTask) {\n        const taskIndex = this.taskQueue.findIndex((task) => task.id === idTask);\n        if (taskIndex !== -1) {\n            this.taskQueue.splice(taskIndex, 1);\n        }\n    }\n    setPointCost(position, cost) {\n        if (!this.pointsCost[position.y]) {\n            this.pointsCost[position.y] = [];\n        }\n        this.pointsCost[position.y][position.x] = cost;\n    }\n    resetPointCost(position) {\n        if (this.pointsCost[position.y]) {\n            delete this.pointsCost[position.y][position.x];\n        }\n    }\n    setWalkable(group, position, state) {\n        const grid = this.grids[group];\n        if (!grid) {\n            return;\n        }\n        grid[position.y][position.x] = state;\n    }\n    next() {\n        const task = this.taskQueue[0];\n        if (!task) {\n            return;\n        }\n        const currentNode = task.takeLastNode();\n        if (currentNode) {\n            if (currentNode.position.x === task.to.x &&\n                currentNode.position.y === task.to.y) {\n                this.taskQueue.shift();\n                task.complete(currentNode.compute());\n            }\n            else {\n                this.getNextDirections(task, currentNode).forEach((offset) => {\n                    const position = {\n                        x: currentNode.position.x + offset.x,\n                        y: currentNode.position.y + offset.y,\n                    };\n                    const nextCost = task.getNextCost(currentNode, offset, this.pointsCost);\n                    const nextNode = task.pickNode(position);\n                    if (nextNode) {\n                        if (nextCost < nextNode.getCost()) {\n                            task.useNode(currentNode, nextNode, nextCost);\n                        }\n                    }\n                    else {\n                        task.addNode(currentNode, position, nextCost);\n                    }\n                });\n            }\n        }\n        else {\n            this.taskQueue.shift();\n            task.complete({\n                path: null,\n                cost: Infinity,\n            });\n        }\n        this.next();\n    }\n    getNextDirections(task, node) {\n        const straightClear = {};\n        const allowedDirs = [];\n        Object.entries(const_1.PATHFINDING_PROCESS_NEXT_DIRECTIINS_STRAIGHT).forEach(([key, direction]) => {\n            if (this.isWalkable(node, task.group, direction)) {\n                straightClear[key] = true;\n                allowedDirs.push(direction);\n            }\n        });\n        Object.entries(const_1.PATHFINDING_PROCESS_NEXT_DIRECTIINS_DIAGONAL).forEach(([key, direction]) => {\n            const clear = straightClear[key[0]] && straightClear[key[1]];\n            if (clear && this.isWalkable(node, task.group, direction)) {\n                allowedDirs.push(direction);\n            }\n        });\n        return allowedDirs;\n    }\n    isWalkable(node, group, direction) {\n        const position = {\n            x: node.position.x + direction.x,\n            y: node.position.y + direction.y,\n        };\n        return this.grids[group]?.[position.y]?.[position.x];\n    }\n}\nexports.PathfindingProcess = PathfindingProcess;\n\n\n//# sourceURL=webpack://pathfinding-worker/./src/process/index.ts?");

/***/ }),

/***/ "./src/task/index.ts":
/*!***************************!*\
  !*** ./src/task/index.ts ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PathfindingTask = void 0;\nconst heap_1 = __importDefault(__webpack_require__(/*! heap */ \"./node_modules/heap/index.js\"));\nconst node_1 = __webpack_require__(/*! ../node */ \"./src/node/index.ts\");\nclass PathfindingTask {\n    from;\n    to;\n    id;\n    group;\n    tree = [];\n    nodes;\n    complete;\n    constructor({ idTask, from, to, group }, onComplete) {\n        this.id = idTask;\n        this.from = { ...from };\n        this.to = { ...to };\n        this.group = group;\n        this.complete = onComplete;\n        this.nodes = new heap_1.default((nodeA, nodeB) => nodeA.getBetterGuessDistance() - nodeB.getBetterGuessDistance());\n        const node = new node_1.PathfindingNode({\n            position: this.from,\n            distance: this.getDistanceFrom(this.from),\n        });\n        this.pushNode(node);\n    }\n    getDistanceFrom(position) {\n        return Math.sqrt((position.x - this.to.x) ** 2 + (position.y - this.to.y) ** 2);\n    }\n    addNode(parent, position, cost) {\n        const node = new node_1.PathfindingNode({\n            position,\n            distance: this.getDistanceFrom(position),\n            cost,\n        });\n        node.setParent(parent);\n        this.pushNode(node);\n    }\n    pushNode(node) {\n        this.nodes.push(node);\n        if (!this.tree[node.position.y]) {\n            this.tree[node.position.y] = [];\n        }\n        this.tree[node.position.y][node.position.x] = node;\n    }\n    pickNode(position) {\n        return this.tree[position.y]?.[position.x];\n    }\n    takeLastNode() {\n        return this.nodes.pop() ?? null;\n    }\n    useNode(current, next, cost) {\n        next.setCost(cost);\n        next.setParent(current);\n        this.nodes.updateItem(next);\n    }\n    getNextCost(currentNode, shift, points) {\n        return currentNode.getCost() + currentNode.getNextCost(shift, points);\n    }\n}\nexports.PathfindingTask = PathfindingTask;\n\n\n//# sourceURL=webpack://pathfinding-worker/./src/task/index.ts?");

/***/ }),

/***/ "./node_modules/ts-loader/index.js!./src/worker/index.ts":
/*!***************************************************************!*\
  !*** ./node_modules/ts-loader/index.js!./src/worker/index.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst worker_threads_1 = __webpack_require__(/*! worker_threads */ \"worker_threads\");\nconst process_1 = __webpack_require__(/*! ../process */ \"./src/process/index.ts\");\nconst task_1 = __webpack_require__(/*! ../task */ \"./src/task/index.ts\");\nconst types_1 = __webpack_require__(/*! ./types */ \"./src/worker/types.ts\");\nconst listeners = new Map();\nconst process = new process_1.PathfindingProcess(worker_threads_1.workerData.grids);\nlisten(types_1.PathfindingWorkerEvent.CreateTask, (payload) => {\n    const task = new task_1.PathfindingTask(payload, (result) => {\n        send(types_1.PathfindingWorkerEvent.CompleteTask, {\n            idTask: payload.idTask,\n            result,\n        });\n    });\n    process.createTask(task);\n});\nlisten(types_1.PathfindingWorkerEvent.CancelTask, (payload) => {\n    process.cancelTask(payload.idTask);\n});\nlisten(types_1.PathfindingWorkerEvent.UpdatePointCost, (payload) => {\n    if (payload.cost === null) {\n        process.resetPointCost(payload.position);\n    }\n    else {\n        process.setPointCost(payload.position, payload.cost);\n    }\n});\nlisten(types_1.PathfindingWorkerEvent.SetWalkable, (payload) => {\n    process.setWalkable(payload.group, payload.position, payload.state);\n});\nworker_threads_1.parentPort?.on(\"message\", (data) => {\n    listeners.get(data.event)?.(data.payload);\n});\nfunction listen(event, callback) {\n    listeners.set(event, callback);\n}\nfunction send(event, payload) {\n    worker_threads_1.parentPort?.postMessage({ event, payload });\n}\n\n\n//# sourceURL=webpack://pathfinding-worker/./src/worker/index.ts?./node_modules/ts-loader/index.js");

/***/ }),

/***/ "./src/worker/types.ts":
/*!*****************************!*\
  !*** ./src/worker/types.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PathfindingWorkerEvent = void 0;\nvar PathfindingWorkerEvent;\n(function (PathfindingWorkerEvent) {\n    PathfindingWorkerEvent[\"CreateTask\"] = \"CreateTask\";\n    PathfindingWorkerEvent[\"CompleteTask\"] = \"CompleteTask\";\n    PathfindingWorkerEvent[\"CancelTask\"] = \"CancelTask\";\n    PathfindingWorkerEvent[\"UpdatePointCost\"] = \"UpdatePointCost\";\n    PathfindingWorkerEvent[\"SetWalkable\"] = \"SetWalkable\";\n})(PathfindingWorkerEvent || (exports.PathfindingWorkerEvent = PathfindingWorkerEvent = {}));\n\n\n//# sourceURL=webpack://pathfinding-worker/./src/worker/types.ts?");

/***/ }),

/***/ "worker_threads":
/*!*********************************!*\
  !*** external "worker_threads" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("worker_threads");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./node_modules/ts-loader/index.js!./src/worker/index.ts");
/******/ 	
/******/ })()
;